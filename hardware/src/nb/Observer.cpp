// This file is part of Man, a robotic perception, locomotion, and
// team strategy application created by the Northern Bites RoboCup
// team of Bowdoin College in Brunswick, Maine, for the Aldebaran
// Nao robot.
//
// Man is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Man is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser Public License for more details.
//
// You should have received a copy of the GNU General Public License
// and the GNU Lesser Public License along with Man.  If not, see
// <http://www.gnu.org/licenses/>.

#include "nb/Observer.h"

using std::list;

using namespace NBMath;

// generated by octave
const double Observer::weights[NUM_AVAIL_PREVIEW_FRAMES] =
        {
                59.556590, 95.02627, 104.31770, 103.40239, 99.17544, 94.03946,
                88.80550, 83.73909, 78.91946, 74.36278, 70.06424, 66.01249,
                62.19447, 58.59708, 55.20770, 52.01434, 49.00569, 46.17106,
                43.50039, 40.98421, 38.61356, 36.38004, 34.27572, 32.29311,
                30.42519, 28.66531, 27.00722, 25.44505, 23.97324, 22.58655,
                21.28008, 20.04918, 18.88948, 17.79686, 16.76744, 15.79756,
                14.88379, 14.02287, 13.21174, 12.44754, 11.72754, 11.04918,
                10.41007, 9.80792, 9.24060, 8.70610, 8.20251, 7.72806,
                7.28104, 6.85989, 6.46309, 6.08925, 5.73703, 5.40518,
                5.09253, 4.79796, 4.52044, 4.25896, 4.01261, 3.78051,
                3.56183, 3.35581, 3.16170, 2.97882, 2.80651, 2.74418,
                2.49123, 2.34713, 2.21137, 2.08345, 1.96294, 1.84940,
                1.74242, 1.64164, 1.54668, 1.45722, 1.37293, 1.29351,
                1.21869, 1.14820, 1.08178, 1.01921, 0.96026, 0.90471,
                0.85238, 0.80308, 0.75663, 0.71286, 0.67163, 0.63278,
                0.59618, 0.56169, 0.52920, 0.49859, 0.46975, 0.44258,
                0.41698, 0.39286, 0.37014, 0.34873, 0.32855, 0.30955,
                0.29164, 0.27478, 0.25888, 0.24391, 0.22980, 0.21651,
                0.20398, 0.19218, 0.18107, 0.17059, 0.16073, 0.15143,
                0.14267, 0.13442, 0.12664, 0.11932, 0.11242, 0.10591
        };

const double Observer::A_values[9] =
        {1.00000, 0.01000, 0.00000,
         0.37692, 1.00000, -0.37692,
         23.26017, 3.78867, -1.33361};

const double Observer::b_values[3] =
        {0.0,
         0.0,
         0.01};

const double Observer::L_values[3] =
        {0.042095,
         -0.338547,
         -0.274121};

const double Observer::c_values[3] =
        {0.0, 0.0, 1.0};

const double Observer::Gi = -59.557;

Observer::Observer()
        : WalkController(), stateVector(ufvector3(3)),
          A(ufmatrix3(3, 3)), b(ufvector3(3)), c(ufrowVector3(1, 3)),
          L(ufvector3(3)), trackingError(0.0) {
    // instantiate the ublas matrices with their respective values
    // TODO: there might be a better way to do this.
    for (int i = 0; i < 3; i++)
        stateVector(i) = 0.0;

    for (int i = 0; i < 3; i++)
        A(0, i) = A_values[i];
    for (int i = 0; i < 3; i++)
        A(1, i) = A_values[3 + i];
    for (int i = 0; i < 3; i++)
        A(2, i) = A_values[6 + i];

    for (int i = 0; i < 3; i++)
        b(i) = b_values[i];

    for (int i = 0; i < 3; i++)
        c(0, i) = c_values[i];

    for (int i = 0; i < 3; i++)
        L(i) = L_values[i];

#ifdef DEBUG_CONTROLLER_GAINS
    FILE * gains_log;
    gains_log = fopen("/tmp/gains_log.xls","w");
    int j = 0;
    fprintf(gains_log,"time\tgain\n");
    //write the controller gains
    for(unsigned int i  = 0; i < NUM_PREVIEW_FRAMES; i++){
        fprintf(gains_log,"%d\t%f\n",j,weights[j]);
        j++;
    }
    fclose(gains_log);
#endif

}

/**
 * Tick calculates the next state vector for the robot, given the zmp_ref
 *
 */
const double Observer::tick(const list<double>* zmp_ref,
                           const double cur_zmp_ref,
                           const double sensor_zmp) {
    double preview_control = 0.0;
    unsigned int counter = 0;

    for (list<double>::const_iterator i = zmp_ref->begin(); counter < NUM_PREVIEW_FRAMES; ++counter, ++i) {
        preview_control += weights[counter] * (*i);
    }

    trackingError += prod(c, stateVector)(0) - cur_zmp_ref;

    const double control = -Gi * trackingError - preview_control;
    const double psensor = sensor_zmp;

    ufvector3 temp(prod(A, stateVector) - L * (psensor - prod(c, stateVector)(0)) * 1.0 + b * control);
    stateVector.assign(temp);

    return getPosition();
}

/**
 * Initialize the position of the robot (vel and accel assumed to be 0)
 * We also assume we are starting off without any tracking error.
 */
void Observer::initState(double x, double v, double p) {
    stateVector(0) = x;
    stateVector(1) = v;
    stateVector(2) = p;
    trackingError = 0.0;
}
