// This file is part of Man, a robotic perception, locomotion, and
// team strategy application created by the Northern Bites RoboCup
// team of Bowdoin College in Brunswick, Maine, for the Aldebaran
// Nao robot.
//
// Man is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Man is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser Public License for more details.
//
// You should have received a copy of the GNU General Public License
// and the GNU Lesser Public License along with Man.  If not, see
// <http://www.gnu.org/licenses/>.

#include "Observer.h"

using std::list;

using namespace NBMath;

// generated by octave
const float Observer::weights[NUM_AVAIL_PREVIEW_FRAMES] =
        {
                59.556590f, 95.02627f, 104.31770f, 103.40239f, 99.17544f, 94.03946f,
                88.80550f, 83.73909f, 78.91946f, 74.36278f, 70.06424f, 66.01249f,
                62.19447f, 58.59708f, 55.20770f, 52.01434f, 49.00569f, 46.17106f,
                43.50039f, 40.98421f, 38.61356f, 36.38004f, 34.27572f, 32.29311f,
                30.42519f, 28.66531f, 27.00722f, 25.44505f, 23.97324f, 22.58655f,
                21.28008f, 20.04918f, 18.88948f, 17.79686f, 16.76744f, 15.79756,
                14.88379f, 14.02287f, 13.21174f, 12.44754f, 11.72754f, 11.04918,
                10.41007f, 9.80792f, 9.24060f, 8.70610f, 8.20251f, 7.72806,
                7.28104f, 6.85989f, 6.46309f, 6.08925f, 5.73703f, 5.40518,
                5.09253f, 4.79796f, 4.52044f, 4.25896f, 4.01261f, 3.78051,
                3.56183f, 3.35581f, 3.16170f, 2.97882f, 2.80651f, 2.74418,
                2.49123f, 2.34713f, 2.21137f, 2.08345f, 1.96294f, 1.84940,
                1.74242f, 1.64164f, 1.54668f, 1.45722f, 1.37293f, 1.29351,
                1.21869f, 1.14820f, 1.08178f, 1.01921f, 0.96026f, 0.90471,
                0.85238f, 0.80308f, 0.75663f, 0.71286f, 0.67163f, 0.63278,
                0.59618f, 0.56169f, 0.52920f, 0.49859f, 0.46975f, 0.44258,
                0.41698f, 0.39286f, 0.37014f, 0.34873f, 0.32855f, 0.30955,
                0.29164f, 0.27478f, 0.25888f, 0.24391f, 0.22980f, 0.21651,
                0.20398f, 0.19218f, 0.18107f, 0.17059f, 0.16073f, 0.15143,
                0.14267f, 0.13442f, 0.12664f, 0.11932f, 0.11242f, 0.10591
        };

const float Observer::A_values[9] =
        {1.00000f, 0.01000f, 0.00000f,
         0.37692f, 1.00000f, -0.37692f,
         23.26017f, 3.78867f, -1.33361f};

const float Observer::b_values[3] =
        {0.0f,
         0.0f,
         0.01f};

const float Observer::L_values[3] =
        {0.042095f,
         -0.338547f,
         -0.274121f};

const float Observer::c_values[3] =
        {0.0f, 0.0f, 1.0f};

const float Observer::Gi = -59.557f;

Observer::Observer()
        : WalkController(), stateVector(ufvector3(3)),
          A(ufmatrix3(3, 3)), b(ufvector3(3)), c(ufrowVector3(1, 3)),
          L(ufvector3(3)), trackingError(0.0f) {
    // instantiate the ublas matrices with their respective values
    // TODO: there might be a better way to do this.
    for (int i = 0; i < 3; i++)
        stateVector(i) = 0.0f;

    for (int i = 0; i < 3; i++)
        A(0, i) = A_values[i];
    for (int i = 0; i < 3; i++)
        A(1, i) = A_values[3 + i];
    for (int i = 0; i < 3; i++)
        A(2, i) = A_values[6 + i];

    for (int i = 0; i < 3; i++)
        b(i) = b_values[i];

    for (int i = 0; i < 3; i++)
        c(0, i) = c_values[i];

    for (int i = 0; i < 3; i++)
        L(i) = L_values[i];

#ifdef DEBUG_CONTROLLER_GAINS
    FILE * gains_log;
    gains_log = fopen("/tmp/gains_log.xls","w");
    int j = 0;
    fprintf(gains_log,"time\tgain\n");
    //write the controller gains
    for(unsigned int i  = 0; i < NUM_PREVIEW_FRAMES; i++){
        fprintf(gains_log,"%d\t%f\n",j,weights[j]);
        j++;
    }
    fclose(gains_log);
#endif

}

/**
 * Tick calculates the next state vector for the robot, given the zmp_ref
 *
 */
const float Observer::tick(const list<float>* zmp_ref,
                           const float cur_zmp_ref,
                           const float sensor_zmp) {
    float preview_control = 0.0f;
    unsigned int counter = 0;

    for (list<float>::const_iterator i = zmp_ref->begin();
         counter < NUM_PREVIEW_FRAMES; ++counter, ++i) {
        preview_control += weights[counter] * (*i);
    }

    trackingError += prod(c, stateVector)(0) - cur_zmp_ref;

    const float control = -Gi * trackingError - preview_control;
    const float psensor = sensor_zmp;

    ufvector3 temp(prod(A, stateVector)
                   - L * (psensor - prod(c, stateVector)(0)) * 1.0f
                   + b * control);
    stateVector.assign(temp);

    return getPosition();
}

/**
 * Initialize the position of the robot (vel and accel assumed to be 0)
 * We also assume we are starting off without any tracking error.
 */
void Observer::initState(float x, float v, float p) {
    stateVector(0) = x;
    stateVector(1) = v;
    stateVector(2) = p;
    trackingError = 0.0f;
}
